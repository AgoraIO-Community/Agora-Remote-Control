// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: EventMessage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "EventMessage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DisplayInfo);
GPBObjCClassDeclaration(EventHeader);
GPBObjCClassDeclaration(KeyboardEvent);
GPBObjCClassDeclaration(MotionEvent);
GPBObjCClassDeclaration(MouseEvent);
GPBObjCClassDeclaration(RspCode);
GPBObjCClassDeclaration(ScreenInfoReq);
GPBObjCClassDeclaration(ScreenInfoRsp);
GPBObjCClassDeclaration(TouchEvent);
GPBObjCClassDeclaration(TraceReq);
GPBObjCClassDeclaration(TraceRsp);

#pragma mark - EventMessageRoot

@implementation EventMessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - EventMessageRoot_FileDescriptor

static GPBFileDescriptor *EventMessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"agora.inputevent.pb.message"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SYSTEM

GPBEnumDescriptor *SYSTEM_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Android\000Ios\000Windows\000";
    static const int32_t values[] = {
        SYSTEM_Android,
        SYSTEM_Ios,
        SYSTEM_Windows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SYSTEM)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SYSTEM_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SYSTEM_IsValidValue(int32_t value__) {
  switch (value__) {
    case SYSTEM_Android:
    case SYSTEM_Ios:
    case SYSTEM_Windows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ACTION

GPBEnumDescriptor *ACTION_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ActionDown\000ActionUp\000ActionMove\000ActionCan"
        "cel\000ActionOutside\000ActionPointerDown\000Acti"
        "onPointerUp\000";
    static const int32_t values[] = {
        ACTION_ActionDown,
        ACTION_ActionUp,
        ACTION_ActionMove,
        ACTION_ActionCancel,
        ACTION_ActionOutside,
        ACTION_ActionPointerDown,
        ACTION_ActionPointerUp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ACTION)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ACTION_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ACTION_IsValidValue(int32_t value__) {
  switch (value__) {
    case ACTION_ActionDown:
    case ACTION_ActionUp:
    case ACTION_ActionMove:
    case ACTION_ActionCancel:
    case ACTION_ActionOutside:
    case ACTION_ActionPointerDown:
    case ACTION_ActionPointerUp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TRACETYPE

GPBEnumDescriptor *TRACETYPE_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RttDelay\000";
    static const int32_t values[] = {
        TRACETYPE_RttDelay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TRACETYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TRACETYPE_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TRACETYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case TRACETYPE_RttDelay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DisplayInfo

@implementation DisplayInfo

@dynamic displayHeight;
@dynamic displayWidth;
@dynamic orientation;
@dynamic system;

typedef struct DisplayInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t displayHeight;
  int32_t displayWidth;
  int32_t orientation;
  SYSTEM system;
} DisplayInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "displayHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayInfo_FieldNumber_DisplayHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayInfo__storage_, displayHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "displayWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayInfo_FieldNumber_DisplayWidth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayInfo__storage_, displayWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "orientation",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayInfo_FieldNumber_Orientation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DisplayInfo__storage_, orientation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "system",
        .dataTypeSpecific.enumDescFunc = SYSTEM_EnumDescriptor,
        .number = DisplayInfo_FieldNumber_System,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DisplayInfo__storage_, system),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayInfo class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\r\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DisplayInfo_System_RawValue(DisplayInfo *message) {
  GPBDescriptor *descriptor = [DisplayInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisplayInfo_FieldNumber_System];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDisplayInfo_System_RawValue(DisplayInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [DisplayInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisplayInfo_FieldNumber_System];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TouchEvent

@implementation TouchEvent

@dynamic pointerIndex;
@dynamic pointerId;
@dynamic logicX;
@dynamic logicY;
@dynamic pressure;
@dynamic size;

typedef struct TouchEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t pointerIndex;
  int32_t pointerId;
  float logicX;
  float logicY;
  float pressure;
  float size;
} TouchEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pointerIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_PointerIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, pointerIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pointerId",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_PointerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, pointerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "logicX",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_LogicX,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, logicX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "logicY",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_LogicY,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, logicY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "pressure",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_Pressure,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, pressure),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = TouchEvent_FieldNumber_Size,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TouchEvent__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TouchEvent class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TouchEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\014\000\002\t\000\003\006\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MotionEvent

@implementation MotionEvent

@dynamic downTime;
@dynamic eventTime;
@dynamic count;
@dynamic action;
@dynamic eventsArray, eventsArray_Count;

typedef struct MotionEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  ACTION action;
  NSMutableArray *eventsArray;
  uint64_t downTime;
  uint64_t eventTime;
} MotionEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "downTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MotionEvent_FieldNumber_DownTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MotionEvent__storage_, downTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eventTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MotionEvent_FieldNumber_EventTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MotionEvent__storage_, eventTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = MotionEvent_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MotionEvent__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = ACTION_EnumDescriptor,
        .number = MotionEvent_FieldNumber_Action,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MotionEvent__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TouchEvent),
        .number = MotionEvent_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MotionEvent__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MotionEvent class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MotionEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MotionEvent_Action_RawValue(MotionEvent *message) {
  GPBDescriptor *descriptor = [MotionEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MotionEvent_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMotionEvent_Action_RawValue(MotionEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [MotionEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MotionEvent_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MouseEvent

@implementation MouseEvent

@dynamic downTime;
@dynamic eventTime;
@dynamic button0;
@dynamic button1;
@dynamic button2;
@dynamic button3;
@dynamic button4;
@dynamic logicX;
@dynamic logicY;
@dynamic axisDltaZ;

typedef struct MouseEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t button0;
  int32_t button1;
  int32_t button2;
  int32_t button3;
  int32_t button4;
  float logicX;
  float logicY;
  int32_t axisDltaZ;
  uint64_t downTime;
  uint64_t eventTime;
} MouseEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "downTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_DownTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, downTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eventTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_EventTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, eventTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "button0",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_Button0,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, button0),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "button1",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_Button1,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, button1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "button2",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_Button2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, button2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "button3",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_Button3,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, button3),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "button4",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_Button4,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, button4),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "logicX",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_LogicX,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, logicX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "logicY",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_LogicY,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, logicY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "axisDltaZ",
        .dataTypeSpecific.clazz = Nil,
        .number = MouseEvent_FieldNumber_AxisDltaZ,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MouseEvent__storage_, axisDltaZ),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MouseEvent class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MouseEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\010\000\002\t\000\010\006\000\t\006\000\n\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyboardEvent

@implementation KeyboardEvent

@dynamic keysArray, keysArray_Count;

typedef struct KeyboardEvent__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolArray *keysArray;
} KeyboardEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KeyboardEvent_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KeyboardEvent__storage_, keysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyboardEvent class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyboardEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RspCode

@implementation RspCode

@dynamic errcode;
@dynamic reason;

typedef struct RspCode__storage_ {
  uint32_t _has_storage_[1];
  int32_t errcode;
  NSString *reason;
} RspCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errcode",
        .dataTypeSpecific.clazz = Nil,
        .number = RspCode_FieldNumber_Errcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RspCode__storage_, errcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = RspCode_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RspCode__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RspCode class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RspCode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TraceReq

@implementation TraceReq

@dynamic traceType;
@dynamic timestamp;

typedef struct TraceReq__storage_ {
  uint32_t _has_storage_[1];
  TRACETYPE traceType;
  uint64_t timestamp;
} TraceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "traceType",
        .dataTypeSpecific.enumDescFunc = TRACETYPE_EnumDescriptor,
        .number = TraceReq_FieldNumber_TraceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TraceReq__storage_, traceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = TraceReq_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TraceReq__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TraceReq class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TraceReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TraceReq_TraceType_RawValue(TraceReq *message) {
  GPBDescriptor *descriptor = [TraceReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TraceReq_FieldNumber_TraceType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTraceReq_TraceType_RawValue(TraceReq *message, int32_t value) {
  GPBDescriptor *descriptor = [TraceReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TraceReq_FieldNumber_TraceType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TraceRsp

@implementation TraceRsp

@dynamic traceType;
@dynamic timestamp;
@dynamic hasRspCode, rspCode;

typedef struct TraceRsp__storage_ {
  uint32_t _has_storage_[1];
  TRACETYPE traceType;
  RspCode *rspCode;
  uint64_t timestamp;
} TraceRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "traceType",
        .dataTypeSpecific.enumDescFunc = TRACETYPE_EnumDescriptor,
        .number = TraceRsp_FieldNumber_TraceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TraceRsp__storage_, traceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = TraceRsp_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TraceRsp__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rspCode",
        .dataTypeSpecific.clazz = GPBObjCClass(RspCode),
        .number = TraceRsp_FieldNumber_RspCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TraceRsp__storage_, rspCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TraceRsp class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TraceRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TraceRsp_TraceType_RawValue(TraceRsp *message) {
  GPBDescriptor *descriptor = [TraceRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TraceRsp_FieldNumber_TraceType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTraceRsp_TraceType_RawValue(TraceRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [TraceRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TraceRsp_FieldNumber_TraceType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ScreenInfoReq

@implementation ScreenInfoReq

@dynamic resolution;

typedef struct ScreenInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t resolution;
} ScreenInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resolution",
        .dataTypeSpecific.clazz = Nil,
        .number = ScreenInfoReq_FieldNumber_Resolution,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScreenInfoReq__storage_, resolution),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScreenInfoReq class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScreenInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScreenInfoRsp

@implementation ScreenInfoRsp

@dynamic screenHeight;
@dynamic screenWidth;
@dynamic screenOrientation;
@dynamic hasRspCode, rspCode;

typedef struct ScreenInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t screenHeight;
  int32_t screenWidth;
  int32_t screenOrientation;
  RspCode *rspCode;
} ScreenInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "screenHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = ScreenInfoRsp_FieldNumber_ScreenHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScreenInfoRsp__storage_, screenHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "screenWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = ScreenInfoRsp_FieldNumber_ScreenWidth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScreenInfoRsp__storage_, screenWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "screenOrientation",
        .dataTypeSpecific.clazz = Nil,
        .number = ScreenInfoRsp_FieldNumber_ScreenOrientation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScreenInfoRsp__storage_, screenOrientation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rspCode",
        .dataTypeSpecific.clazz = GPBObjCClass(RspCode),
        .number = ScreenInfoRsp_FieldNumber_RspCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScreenInfoRsp__storage_, rspCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScreenInfoRsp class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScreenInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\014\000\002\013\000\003\021\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EventHeader

@implementation EventHeader

@dynamic version;
@dynamic sequence;

typedef struct EventHeader__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  int64_t sequence;
} EventHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = EventHeader_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EventHeader__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.clazz = Nil,
        .number = EventHeader_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EventHeader__storage_, sequence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EventHeader class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EventHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UplinkMessage

@implementation UplinkMessage

@dynamic hasEventHeader, eventHeader;
@dynamic hasMotionEvent, motionEvent;
@dynamic hasMouseEvent, mouseEvent;
@dynamic hasKeyboardEvent, keyboardEvent;
@dynamic hasTraceReq, traceReq;
@dynamic hasScreenInfoReq, screenInfoReq;
@dynamic hasDisplayInfo, displayInfo;

typedef struct UplinkMessage__storage_ {
  uint32_t _has_storage_[1];
  EventHeader *eventHeader;
  MotionEvent *motionEvent;
  MouseEvent *mouseEvent;
  KeyboardEvent *keyboardEvent;
  TraceReq *traceReq;
  ScreenInfoReq *screenInfoReq;
  DisplayInfo *displayInfo;
} UplinkMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventHeader",
        .dataTypeSpecific.clazz = GPBObjCClass(EventHeader),
        .number = UplinkMessage_FieldNumber_EventHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, eventHeader),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "motionEvent",
        .dataTypeSpecific.clazz = GPBObjCClass(MotionEvent),
        .number = UplinkMessage_FieldNumber_MotionEvent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, motionEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mouseEvent",
        .dataTypeSpecific.clazz = GPBObjCClass(MouseEvent),
        .number = UplinkMessage_FieldNumber_MouseEvent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, mouseEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyboardEvent",
        .dataTypeSpecific.clazz = GPBObjCClass(KeyboardEvent),
        .number = UplinkMessage_FieldNumber_KeyboardEvent,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, keyboardEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceReq",
        .dataTypeSpecific.clazz = GPBObjCClass(TraceReq),
        .number = UplinkMessage_FieldNumber_TraceReq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, traceReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenInfoReq",
        .dataTypeSpecific.clazz = GPBObjCClass(ScreenInfoReq),
        .number = UplinkMessage_FieldNumber_ScreenInfoReq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, screenInfoReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(DisplayInfo),
        .number = UplinkMessage_FieldNumber_DisplayInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UplinkMessage__storage_, displayInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UplinkMessage class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UplinkMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\013\000\003\n\000\004\r\000\005\010\000\006\r\000\007\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownlinkMessage

@implementation DownlinkMessage

@dynamic hasEventHeader, eventHeader;
@dynamic hasTraceRsp, traceRsp;
@dynamic hasScreenInfoRsp, screenInfoRsp;

typedef struct DownlinkMessage__storage_ {
  uint32_t _has_storage_[1];
  EventHeader *eventHeader;
  TraceRsp *traceRsp;
  ScreenInfoRsp *screenInfoRsp;
} DownlinkMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventHeader",
        .dataTypeSpecific.clazz = GPBObjCClass(EventHeader),
        .number = DownlinkMessage_FieldNumber_EventHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownlinkMessage__storage_, eventHeader),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceRsp",
        .dataTypeSpecific.clazz = GPBObjCClass(TraceRsp),
        .number = DownlinkMessage_FieldNumber_TraceRsp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownlinkMessage__storage_, traceRsp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenInfoRsp",
        .dataTypeSpecific.clazz = GPBObjCClass(ScreenInfoRsp),
        .number = DownlinkMessage_FieldNumber_ScreenInfoRsp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownlinkMessage__storage_, screenInfoRsp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownlinkMessage class]
                                     rootClass:[EventMessageRoot class]
                                          file:EventMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownlinkMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\010\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
